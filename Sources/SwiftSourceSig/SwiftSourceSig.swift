import CryptoKit
import Foundation

public enum SwiftSourceSig {
    
    public static var startingHeader: String {
        """
            // Automatically generated
            // Do not edit directly!
            // swift-format-ignore-file
            
            """
    }
    public static var startingHeaderWhenManualSectionsArePresent: String {
        """
            // This file is automatically generated, but has editable manual sections.
            // Only edit the code between the manual sections.
            // Do NOT edit code outside of the manual sections.
            // Use the SwiftSourceSigLintBuildTool plugin via SPM to verify that generated code is not modified.
            // swift-format-ignore-file
            
            """
    }
    
    @available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 13.0, *)
    public static func signFile(_ code: String, previousState: String? = nil) throws(SwiftSourceSigError) -> String {
        let parsed = try ParsedCode(code: code)
        let saved: ParsedCode = if let previousState {
            try ParsedCode(code: previousState)
        } else {
            ParsedCode(sections: [])
        }
        let synthesized = parsed.signAndSynthesize(with: saved)
        return try synthesized.toString()
    }

    @available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 13.0, *)
    public static func validate(_ code: String) throws(SwiftSourceSigError) {
        let parsed = try ParsedCode(code: code)
        for section in parsed.sections {
           switch section {
           case .generated(let codeHash, let code, let loc):
                let digest = SHA512.hash(data: Data(code.utf8))
                let hashStr = String(digest.map { String(format: "%02x", $0) }.joined().prefix(16))
                if hashStr != codeHash {
                    throw SwiftSourceSigError(message: "Generated code hash mismatch. (Found '\(codeHash)' expected '\(hashStr)')", lineOfCodeStart: loc)
                }
            default:
                break
            }
        }
    }
}

struct ParsedCode {
    private(set) var sections: [Section]
    
    enum Section {
        case generated(
            codeHash: String,
            code: String,
            loc: Int
        )
        case manual(
            manualSectionName: String,
            code: String
        )
        case unsignedGenerated(code: String)
        case manualPlaceholder(manualSectionName: String)
    }
    
    init(sections: [Section]) {
        self.sections = sections
    }
    
    init(code: String) throws(SwiftSourceSigError) {
        var code = code
        var lineNumberExtra = 0
        if code.hasPrefix(SwiftSourceSig.startingHeader) {
            code.removeFirst(SwiftSourceSig.startingHeader.count)
            lineNumberExtra += SwiftSourceSig.startingHeader.split(separator: "\n").count
        } else if code.hasPrefix(SwiftSourceSig.startingHeaderWhenManualSectionsArePresent) {
            code.removeFirst(SwiftSourceSig.startingHeaderWhenManualSectionsArePresent.count)
            lineNumberExtra += SwiftSourceSig.startingHeaderWhenManualSectionsArePresent.split(separator: "\n").count
        }
        if code.isEmpty {
            self.init(sections: [])
            return
        }
        let lines = code.toLines()
        var parsedSections: [Section] = []
        var i = 0
        let generatedStart = "// @generated-section-start "
        let generatedEnd = "// @generated-section-end "
        let manualStart = "// @manual-section-start "
        let manualEnd = "// @manual-section-end "
        let manualPlaceholder = "@manual-section-placeholder "

        while i < lines.count {
            let line = lines[i]
            let trimmed = line.line.trimmingCharacters(in: .whitespaces)

            if trimmed.hasPrefix(generatedStart) {
                let hash = String(trimmed.dropFirst(generatedStart.count)).trimmingCharacters(in: .whitespaces)
                i += 1
                var codeLines: [String] = []
                while i < lines.count {
                    let l = lines[i]
                    let t = l.line.trimmingCharacters(in: .whitespaces)
                    if t.hasPrefix(generatedEnd) {
                        let endHash = String(t.dropFirst(generatedEnd.count)).trimmingCharacters(in: .whitespaces)
                        if endHash == hash {
                            i += 1
                            break
                        }
                    }
                    codeLines.append(l.line)
                    i += 1
                }
                parsedSections.append(.generated(
                    codeHash: hash,
                    code: codeLines.joined(separator: "\n"),
                    loc: line.loc + lineNumberExtra
                ))
                continue
            }

            if trimmed.hasPrefix(manualStart) {
                let name = String(trimmed.dropFirst(manualStart.count)).trimmingCharacters(in: .whitespaces)
                i += 1
                var codeLines: [String] = []
                while i < lines.count {
                    let l = lines[i]
                    let t = l.line.trimmingCharacters(in: .whitespaces)
                    if t.hasPrefix(manualEnd) {
                        let endName = String(t.dropFirst(manualEnd.count)).trimmingCharacters(in: .whitespaces)
                        if endName == name {
                            i += 1
                            break
                        }
                    }
                    codeLines.append(l.line)
                    i += 1
                }
                parsedSections.append(.manual(manualSectionName: name, code: codeLines.joined(separator: "\n")))
                continue
            }

            if trimmed.hasPrefix(manualPlaceholder) {
                let name = String(trimmed.dropFirst(manualPlaceholder.count)).trimmingCharacters(in: .whitespaces)
                parsedSections.append(.manualPlaceholder(manualSectionName: name))
                i += 1
                continue
            }

            // Unsigned generated: collect consecutive lines until next directive
            var codeLines: [String] = []
            while i < lines.count {
                let l = lines[i]
                let t = l.line.trimmingCharacters(in: .whitespaces)
                if t.hasPrefix(generatedStart) || t.hasPrefix(manualStart) || t.hasPrefix(manualPlaceholder) {
                    break
                }
                codeLines.append(l.line)
                i += 1
            }
            let block = codeLines.joined(separator: "\n").trimmingCharacters(in: .whitespacesAndNewlines)
            if !block.isEmpty {
                parsedSections.append(.unsignedGenerated(code: block))
            }
        }

        self.init(sections: parsedSections)
    }
    
    func toString() throws(SwiftSourceSigError) -> String {
        var render = ""
        if sections.contains(where: { if case .manualPlaceholder = $0 { return true }; return false }) {
            render.append(SwiftSourceSig.startingHeaderWhenManualSectionsArePresent)
        } else {
            render.append(SwiftSourceSig.startingHeader)
        }
        for section in sections {
            switch section {
            case .generated(let codeHash, let code, _):
                render.append("\n")
                render.append("// @generated-section-start \(codeHash)")
                render.append("\n")
                render.append(code)
                render.append("\n")
                render.append("// @generated-section-end \(codeHash)")
                render.append("\n")
            case .manual(let manualSectionName, let code):
                render.append("\n")
                render.append("// @manual-section-start \(manualSectionName)")
                render.append("\n")
                render.append(code)
                render.append("\n")
                render.append("// @manual-section-end \(manualSectionName)")
                render.append("\n")
            case .unsignedGenerated(let code):
                throw SwiftSourceSigError(message: "Unsigned generated code found '\(code.components(separatedBy: "\n").first(where: {$0.trimmingCharacters(in: .whitespacesAndNewlines).count > 0}) ?? "")'")
            case .manualPlaceholder(let manualSectionName):
                render.append("\n")
                render.append("// @manual-section-start \(manualSectionName)")
                render.append("\n")
                render.append("\n")
                render.append("// Write your own code here for \(manualSectionName)")
                render.append("\n")
                render.append("\n")
                render.append("// @manual-section-end \(manualSectionName)")
                render.append("\n")
            }
        }
        return render
    }

    @available(iOS 13.0, macOS 10.15, watchOS 6.0, tvOS 13.0, *)
    func signAndSynthesize(with saved: ParsedCode) -> ParsedCode {
        var result: [Section] = []
        for section in sections {
            switch section {
            case .unsignedGenerated(let code):
                let digest = SHA512.hash(data: Data(code.utf8))
                let hashStr = String(digest.map { String(format: "%02x", $0) }.joined().prefix(16))
                result.append(.generated(codeHash: hashStr, code: code, loc: -1))
            case .manualPlaceholder(let name):
                guard let savedSection = saved.sections.first(where: {
                    if case .manual(let n, _) = $0 { return n == name }
                    return false
                }), case .manual(_, let code) = savedSection else {
                    result.append(.manual(
                        manualSectionName: name,
                        code: "// Write your code here"
                    ))
                    continue
                }
                result.append(.manual(manualSectionName: name, code: code))
            case .generated(let codeHash, let code, let loc):
                result.append(.generated(codeHash: codeHash, code: code, loc: loc))
            case .manual(let manualSectionName, let code):
                result.append(.manual(manualSectionName: manualSectionName, code: code))
            }
        }
        return ParsedCode(sections: result)
    }
}

public struct SwiftSourceSigError: Error {
    public let message: String
    public var lineOfCodeStart: Int?
}

extension String {
    func toLines() -> [(loc: Int, line: String)] {
        var lines: [(loc: Int, line: String)] = []
        var line = ""
        var loc = 1
        for c in self {
            if c.isNewline {
                lines.append((loc: loc, line: line))
                line = ""
                loc += 1
            } else {
                line.append(c)
            }
        }
        if !line.isEmpty {
            lines.append((loc: loc, line: line))
        }
        return lines
    }
}
